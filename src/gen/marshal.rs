use std;
use std::path::Path;

use parser;
use gen::util;

pub fn gen(exports: &Vec<parser::FuncDecl>, dest: &Path) -> std::io::Result<()> {
    let mut content = String::new();

    for func in exports {
        if let Some(func_name) = get_mangled_fn(func) {
            append_func(func, &func_name, &mut content);
        } 
    }

    if content.len() > 0 {
        let output = dest.join("ffigen").join("mod.rs");

        let final_content = append_header(&content);

        util::write_source(&final_content, &output)
    } else {
        Ok(())
    }
}

pub fn get_mangled_fn(func: &parser::FuncDecl) -> Option<String> {
    let marshaled_name = format!("{}_marshal", func.name);
    let should_marshal = |ty: &parser::Type| {
        match *ty {
            parser::Type::String | parser::Type::StringRef => true,
            parser::Type::Str | parser::Type::StrRef => true,
            _ => false
        }
    };

    let arg_marshal = func.args.iter()
        .any(|ref arg| should_marshal(&arg.ty));

    let ret_marshal = match func.ret {
        parser::ReturnType::Void => false,
        parser::ReturnType::Type(t) => should_marshal(&t)
    };

    if arg_marshal || ret_marshal {
        Some(marshaled_name)
    } else {
        None
    }
}

fn append_func(func: &parser::FuncDecl, func_name: &String, content: &mut String) {
    let mut params = String::new();
    let mut func_body = String::new();
    let mut func_invoke = format!("\tsuper::{}{}(", func.module, func.name);

    for arg in &func.args {
        if params.len() > 0 {
            params.push_str(", ");
            func_invoke.push_str(", ");
        }

        let param_dec = format!("{}: {}", arg.name, translate_type(arg.ty));
        if let Some((shadowed_name, shadowed_val)) = get_shadowed_value(arg) {
            let shadowed_name_ref = format!("&{}", &shadowed_name);
            func_body.push_str(shadowed_val.as_ref());
            func_invoke.push_str(shadowed_name_ref.as_ref());
        } else {
            func_invoke.push_str(arg.name.as_ref());
        }

        params.push_str(param_dec.as_ref());
    }

    let func_decl = match func.ret {
        parser::ReturnType::Void => format!("pub extern fn {}({}) {{\n", func_name, params),
        parser::ReturnType::Type(t) => format!("pub extern fn {}({}) -> {} {{\n", func_name, params, translate_type(t))
    };

    func_invoke.push_str(");\n");

    func_body.push_str(func_invoke.as_ref());

    content.push_str(func_decl.as_ref());
    content.push_str(func_body.as_ref());
    content.push_str("}\n");
}

fn append_header(content: &String) -> String {
    let mut final_content = r"// THIS IS AN AUTOGENERATED FILE
// DO NOT MODIFY!

extern crate ffigen;

".to_string();

    final_content.push_str(content.as_ref());

    final_content
}

fn get_shadowed_value(arg: &parser::Arg) -> Option<(String, String)> {
    match arg.ty {
        parser::Type::StringRef => {
            let shadowed_name = format!("{}_shadow", arg.name);
            let shadowed_decl = format!("\tlet {} = ffigen::marshal::cstr_to_string({});\n", shadowed_name, arg.name);

            Some((shadowed_name, shadowed_decl))
        },
        _=> None
    }
}

fn translate_type(ty: parser::Type) -> &'static str {
    match ty {
        parser::Type::U32 => "u32",
        parser::Type::U16 => "u16",
        parser::Type::U8 => "u8",
        parser::Type::I32 => "i32",
        parser::Type::I16 => "i16",
        parser::Type::I8 => "i8",
        parser::Type::F32 => "f32",
        parser::Type::F64 => "f64",
        parser::Type::Boolean => "bool",
		parser::Type::String => "*const u8",
        parser::Type::StringRef => "*const u8",
        parser::Type::Str => "*const u8",
        parser::Type::StrRef => "*const u8"
    }
}